<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pedro's Comic Collection</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>.loader { border-top-color: transparent; }</style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const SUPABASE_URL = 'https://ykumllgvkhfvvgrhodue.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlrdW1sbGd2a2hmdnZncmhvZHVlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg2MTk5MTcsImV4cCI6MjA4NDE5NTkxN30.Oy-f0yrZrrO9NNMXMg1j4wJYhU_YQBhiIx7N5fXgx7A';

    const supabase = {
      from: (table) => ({
        select: async (columns = '*') => {
          const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?select=${columns}`, {
            headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` }
          });
          return { data: await res.json(), error: res.ok ? null : 'Error' };
        },
        insert: async (rows) => {
          const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}`, {
            method: 'POST',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
              'Content-Type': 'application/json',
              'Prefer': 'return=representation'
            },
            body: JSON.stringify(rows)
          });
          return { data: await res.json(), error: res.ok ? null : 'Error' };
        },
        update: (updates) => ({
          eq: async (col, val) => {
            const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?${col}=eq.${val}`, {
              method: 'PATCH',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation'
              },
              body: JSON.stringify(updates)
            });
            return { data: await res.json(), error: res.ok ? null : 'Error' };
          }
        }),
        delete: () => ({
          eq: async (col, val) => {
            const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?${col}=eq.${val}`, {
              method: 'DELETE',
              headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` }
            });
            return { error: res.ok ? null : 'Error' };
          }
        })
      })
    };

    // Parse LOCG title to extract issue number and cover info
    function parseLOCGTitle(fullTitle, seriesName) {
      // Remove series name from beginning
      let remaining = fullTitle.replace(seriesName, '').trim();
      
      // Extract issue number (e.g., "#15", "#1")
      const issueMatch = remaining.match(/#(\d+[A-Z]?)/i);
      const issueNumber = issueMatch ? `#${issueMatch[1]}` : remaining.split(' ')[0];
      
      // Extract cover info (everything after issue number)
      let cover = 'Cover A';
      const coverPatterns = [
        /Cover ([A-Z])/i,
        /(Variant|Var)/i,
        /(\d+:\d+)/,  // Ratio variants like 1:25
        /(Foil|Acetate|Card Stock)/i,
      ];
      
      // Check for specific cover mentions
      if (remaining.toLowerCase().includes('variant') || remaining.toLowerCase().includes('var')) {
        cover = remaining.replace(issueMatch ? issueMatch[0] : '', '').trim() || 'Variant';
      } else if (remaining.match(/Cover ([A-Z])/i)) {
        cover = `Cover ${remaining.match(/Cover ([A-Z])/i)[1]}`;
      } else {
        // Try to get descriptive cover name
        const afterIssue = remaining.replace(issueMatch ? issueMatch[0] : '', '').trim();
        if (afterIssue) cover = afterIssue;
      }
      
      return { issueNumber, cover };
    }

    // Match LOCG series name to our series
    function matchSeries(locgSeriesName, seriesList) {
      const normalized = locgSeriesName.toLowerCase().trim();
      
      // Direct match
      let match = seriesList.find(s => s.name.toLowerCase() === normalized);
      if (match) return match;
      
      // Partial match
      match = seriesList.find(s => 
        normalized.includes(s.name.toLowerCase()) || 
        s.name.toLowerCase().includes(normalized)
      );
      if (match) return match;
      
      // Fuzzy match for common variations
      const variations = {
        'absolute batman': 'Absolute Batman',
        'absolute superman': 'Absolute Superman',
        'absolute wonder woman': 'Absolute Wonder Woman',
        'absolute flash': 'Absolute Flash',
        'absolute green lantern': 'Absolute Green Lantern',
        'absolute martian manhunter': 'Absolute Martian Manhunter',
        'ultimate spider-man': 'Ultimate Spider-Man',
        'ultimate x-men': 'Ultimate X-Men',
      };
      
      for (const [key, val] of Object.entries(variations)) {
        if (normalized.includes(key)) {
          return seriesList.find(s => s.name === val);
        }
      }
      
      return null;
    }

    function App() {
      const [activeTab, setActiveTab] = useState('overview');
      const [series, setSeries] = useState([]);
      const [issues, setIssues] = useState([]);
      const [gaps, setGaps] = useState([]);
      const [gifts, setGifts] = useState([]);
      const [loading, setLoading] = useState(true);
      const [expanded, setExpanded] = useState({});
      const [filter, setFilter] = useState('all');
      const [showAdmin, setShowAdmin] = useState(false);
      const [adminMode, setAdminMode] = useState('add-issue');
      const [message, setMessage] = useState('');
      const [saving, setSaving] = useState(false);
      
      // Import state
      const [importData, setImportData] = useState(null);
      const [importPreview, setImportPreview] = useState([]);
      const [importStats, setImportStats] = useState({ new: 0, existing: 0, unmatched: 0 });
      const fileInputRef = useRef(null);

      // Admin form states
      const [newIssue, setNewIssue] = useState({ series_id: '', issue_number: '', covers: '', status: 'pending', notes: '' });
      const [newSeries, setNewSeries] = useState({ name: '', publisher: 'DC', status: 'in-progress', total_spent: 0 });

      useEffect(() => { fetchData(); }, []);

      const fetchData = async () => {
        setLoading(true);
        try {
          const [seriesRes, issuesRes, gapsRes, giftsRes] = await Promise.all([
            supabase.from('series').select('*'),
            supabase.from('issues').select('*'),
            supabase.from('gaps').select('*'),
            supabase.from('gifts').select('*')
          ]);
          setSeries(seriesRes.data || []);
          setIssues(issuesRes.data || []);
          setGaps(gapsRes.data || []);
          setGifts(giftsRes.data || []);
        } catch (err) {
          console.error(err);
        } finally {
          setLoading(false);
        }
      };

      const toggleExpand = (id) => setExpanded(p => ({ ...p, [id]: !p[id] }));
      
      const showMessage = (msg) => {
        setMessage(msg);
        setTimeout(() => setMessage(''), 4000);
      };

      // LOCG Import Handler
      const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (evt) => {
          const data = evt.target.result;
          const workbook = XLSX.read(data, { type: 'binary' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(sheet);
          
          // Process and match
          const processed = json
            .filter(row => row['In Collection'] === 1) // Only items in collection
            .map(row => {
              const seriesName = row['Series Name'] || '';
              const fullTitle = row['Full Title'] || '';
              const matchedSeries = matchSeries(seriesName, series);
              const { issueNumber, cover } = parseLOCGTitle(fullTitle, seriesName);
              
              // Check if already exists
              const exists = matchedSeries && issues.some(i => 
                i.series_id === matchedSeries.id && 
                i.issue_number === issueNumber &&
                i.covers?.some(c => c.toLowerCase().includes(cover.toLowerCase().substring(0, 10)))
              );
              
              return {
                raw: row,
                publisher: row['Publisher Name'],
                seriesName,
                fullTitle,
                issueNumber,
                cover,
                matchedSeries,
                exists,
                status: exists ? 'existing' : (matchedSeries ? 'new' : 'unmatched'),
                import: !exists && matchedSeries
              };
            });
          
          setImportData(json);
          setImportPreview(processed);
          setImportStats({
            new: processed.filter(p => p.status === 'new').length,
            existing: processed.filter(p => p.status === 'existing').length,
            unmatched: processed.filter(p => p.status === 'unmatched').length
          });
        };
        reader.readAsBinaryString(file);
      };

      const executeImport = async () => {
        setSaving(true);
        const toImport = importPreview.filter(p => p.import && p.matchedSeries);
        
        // Group by series and issue to combine covers
        const grouped = {};
        toImport.forEach(item => {
          const key = `${item.matchedSeries.id}-${item.issueNumber}`;
          if (!grouped[key]) {
            grouped[key] = {
              series_id: item.matchedSeries.id,
              issue_number: item.issueNumber,
              covers: [],
              status: 'owned',
              notes: null
            };
          }
          if (!grouped[key].covers.includes(item.cover)) {
            grouped[key].covers.push(item.cover);
          }
        });
        
        const inserts = Object.values(grouped);
        
        if (inserts.length > 0) {
          const { error } = await supabase.from('issues').insert(inserts);
          if (error) {
            showMessage(`Error importing: ${error}`);
          } else {
            showMessage(`Successfully imported ${inserts.length} issues!`);
            setImportData(null);
            setImportPreview([]);
            fetchData();
          }
        }
        setSaving(false);
      };

      // LOCG Export Handler
      const exportForLOCG = () => {
        const rows = [];
        
        issues.forEach(issue => {
          const issueSeries = series.find(s => s.id === issue.series_id);
          if (!issueSeries) return;
          
          // Create a row for each cover
          (issue.covers || ['Cover A']).forEach(cover => {
            const fullTitle = `${issueSeries.name} ${issue.issue_number} ${cover}`.trim();
            rows.push({
              'Publisher Name': issueSeries.publisher || 'DC',
              'Series Name': issueSeries.name,
              'Full Title': fullTitle,
              'Release Date': '',
              'In Collection': issue.status === 'owned' ? 1 : 0,
              'In Wish List': issue.status === 'wishlist' ? 1 : 0,
              'Marked Read': 1,
              'My Rating': '',
              'Media Format': 'Single Issue',
              'Price Paid': issue.price_paid || '',
              'Date Purchased': '',
              'Condition': '',
              'Notes': issue.notes || '',
              'Tags': ''
            });
          });
        });
        
        const ws = XLSX.utils.json_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Comics');
        XLSX.writeFile(wb, `ComicGeeks_Export_${new Date().toISOString().slice(0,10)}.xlsx`);
        showMessage('Export complete! File downloaded.');
      };

      const handleAddIssue = async (e) => {
        e.preventDefault();
        setSaving(true);
        const coversArray = newIssue.covers.split(',').map(c => c.trim()).filter(c => c);
        const { error } = await supabase.from('issues').insert({
          series_id: parseInt(newIssue.series_id),
          issue_number: newIssue.issue_number,
          covers: coversArray,
          status: newIssue.status,
          notes: newIssue.notes || null
        });
        setSaving(false);
        if (!error) {
          showMessage('Issue added!');
          setNewIssue({ series_id: '', issue_number: '', covers: '', status: 'pending', notes: '' });
          fetchData();
        } else {
          showMessage('Error adding issue');
        }
      };

      const handleAddSeries = async (e) => {
        e.preventDefault();
        setSaving(true);
        const { error } = await supabase.from('series').insert(newSeries);
        setSaving(false);
        if (!error) {
          showMessage('Series added!');
          setNewSeries({ name: '', publisher: 'DC', status: 'in-progress', total_spent: 0 });
          fetchData();
        } else {
          showMessage('Error adding series');
        }
      };

      const markAsOwned = async (issueId) => {
        await supabase.from('issues').update({ status: 'owned' }).eq('id', issueId);
        fetchData();
      };

      // Stats
      const totalSpent = series.reduce((sum, s) => sum + (parseFloat(s.total_spent) || 0), 0);
      const ownedBooks = issues.filter(i => i.status === 'owned').length;
      const pendingBooks = issues.filter(i => i.status === 'pending').length;
      const completeRuns = series.filter(s => s.status === 'complete').length;
      const getSeriesIssues = (seriesId) => issues.filter(i => i.series_id === seriesId);

      const StatusBadge = ({ status }) => {
        const colors = {
          'complete': 'bg-green-100 text-green-800',
          'near-complete': 'bg-yellow-100 text-yellow-800',
          'in-progress': 'bg-blue-100 text-blue-800',
          'misc': 'bg-gray-100 text-gray-800',
          'owned': 'bg-green-100 text-green-800',
          'pending': 'bg-yellow-100 text-yellow-800',
          'new': 'bg-blue-100 text-blue-800',
          'existing': 'bg-gray-100 text-gray-600',
          'unmatched': 'bg-red-100 text-red-800',
        };
        return <span className={`px-2 py-0.5 rounded text-xs font-medium ${colors[status] || 'bg-gray-100'}`}>{status}</span>;
      };

      const filteredSeries = series.filter(s => {
        if (filter === 'all') return true;
        if (filter === 'complete') return s.status === 'complete';
        if (filter === 'in-progress') return s.status === 'in-progress' || s.status === 'near-complete';
        if (filter === 'dc') return s.publisher === 'DC';
        if (filter === 'marvel') return s.publisher === 'Marvel';
        return true;
      }).sort((a, b) => a.name.localeCompare(b.name));

      if (loading) {
        return (
          <div className="p-8 text-center min-h-screen bg-gray-50">
            <div className="loader animate-spin w-8 h-8 border-4 border-blue-500 rounded-full mx-auto mb-4"></div>
            <p className="text-gray-500">Loading from Supabase...</p>
          </div>
        );
      }

      return (
        <div className="p-4 max-w-5xl mx-auto bg-gray-50 min-h-screen">
          {/* Header */}
          <div className="flex justify-between items-center mb-4">
            <div>
              <h1 className="text-2xl font-bold">Pedro's Comic Collection</h1>
              <p className="text-sm text-gray-500">Powered by Supabase ‚Ä¢ Syncs with LOCG</p>
            </div>
            <div className="flex gap-2">
              <button onClick={fetchData} className="px-3 py-1 bg-gray-200 rounded text-sm hover:bg-gray-300">‚Üª Refresh</button>
              <button onClick={() => setShowAdmin(!showAdmin)} className={`px-3 py-1 rounded text-sm ${showAdmin ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
                {showAdmin ? '‚úï Close' : '‚öô Admin'}
              </button>
            </div>
          </div>

          {message && <div className="mb-4 p-3 bg-green-100 text-green-800 rounded">{message}</div>}

          {/* Admin Panel */}
          {showAdmin && (
            <div className="bg-white rounded shadow p-4 mb-4 border-2 border-blue-200">
              <div className="flex gap-2 mb-4 flex-wrap">
                {['add-issue', 'add-series', 'mark-owned', 'import', 'export'].map(mode => (
                  <button key={mode} onClick={() => setAdminMode(mode)} 
                    className={`px-3 py-1 rounded text-sm ${adminMode === mode ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
                    {mode === 'import' ? 'üì• Import LOCG' : mode === 'export' ? 'üì§ Export LOCG' : mode.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}
                  </button>
                ))}
              </div>

              {adminMode === 'add-issue' && (
                <form onSubmit={handleAddIssue} className="space-y-3">
                  <div className="grid grid-cols-2 gap-3">
                    <select value={newIssue.series_id} onChange={e => setNewIssue({...newIssue, series_id: e.target.value})} className="p-2 border rounded" required>
                      <option value="">Select Series</option>
                      {series.sort((a,b) => a.name.localeCompare(b.name)).map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                    </select>
                    <input type="text" placeholder="Issue # (e.g. #18)" value={newIssue.issue_number} onChange={e => setNewIssue({...newIssue, issue_number: e.target.value})} className="p-2 border rounded" required />
                  </div>
                  <input type="text" placeholder="Covers (comma separated)" value={newIssue.covers} onChange={e => setNewIssue({...newIssue, covers: e.target.value})} className="w-full p-2 border rounded" required />
                  <div className="grid grid-cols-2 gap-3">
                    <select value={newIssue.status} onChange={e => setNewIssue({...newIssue, status: e.target.value})} className="p-2 border rounded">
                      <option value="pending">Pending</option>
                      <option value="owned">Owned</option>
                      <option value="wishlist">Wishlist</option>
                    </select>
                    <input type="text" placeholder="Notes (optional)" value={newIssue.notes} onChange={e => setNewIssue({...newIssue, notes: e.target.value})} className="p-2 border rounded" />
                  </div>
                  <button type="submit" disabled={saving} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50">
                    {saving ? 'Adding...' : 'Add Issue'}
                  </button>
                </form>
              )}

              {adminMode === 'add-series' && (
                <form onSubmit={handleAddSeries} className="space-y-3">
                  <input type="text" placeholder="Series Name" value={newSeries.name} onChange={e => setNewSeries({...newSeries, name: e.target.value})} className="w-full p-2 border rounded" required />
                  <div className="grid grid-cols-3 gap-3">
                    <select value={newSeries.publisher} onChange={e => setNewSeries({...newSeries, publisher: e.target.value})} className="p-2 border rounded">
                      <option value="DC">DC</option>
                      <option value="Marvel">Marvel</option>
                      <option value="Image">Image</option>
                      <option value="Dark Horse">Dark Horse</option>
                      <option value="Various">Various</option>
                    </select>
                    <select value={newSeries.status} onChange={e => setNewSeries({...newSeries, status: e.target.value})} className="p-2 border rounded">
                      <option value="in-progress">In Progress</option>
                      <option value="complete">Complete</option>
                      <option value="near-complete">Near Complete</option>
                      <option value="misc">Misc</option>
                    </select>
                    <input type="number" placeholder="Total Spent" value={newSeries.total_spent} onChange={e => setNewSeries({...newSeries, total_spent: e.target.value})} className="p-2 border rounded" />
                  </div>
                  <button type="submit" disabled={saving} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50">
                    {saving ? 'Adding...' : 'Add Series'}
                  </button>
                </form>
              )}

              {adminMode === 'mark-owned' && (
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  <p className="text-sm text-gray-500 mb-2">Click to mark pending items as owned:</p>
                  {issues.filter(i => i.status === 'pending').map(issue => {
                    const issueSeries = series.find(s => s.id === issue.series_id);
                    return (
                      <div key={issue.id} className="p-2 border rounded flex justify-between items-center hover:bg-gray-50">
                        <div>
                          <span className="font-medium">{issueSeries?.name}</span>
                          <span className="text-gray-500 ml-2">{issue.issue_number}</span>
                        </div>
                        <button onClick={() => markAsOwned(issue.id)} className="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600">‚úì Owned</button>
                      </div>
                    );
                  })}
                  {issues.filter(i => i.status === 'pending').length === 0 && (
                    <p className="text-gray-400 text-center py-4">No pending items</p>
                  )}
                </div>
              )}

              {adminMode === 'import' && (
                <div className="space-y-4">
                  <div className="border-2 border-dashed border-gray-300 rounded p-6 text-center">
                    <input type="file" ref={fileInputRef} accept=".xlsx,.xls,.csv" onChange={handleFileUpload} className="hidden" />
                    <button onClick={() => fileInputRef.current?.click()} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                      üìÅ Select LOCG Export File
                    </button>
                    <p className="text-sm text-gray-500 mt-2">Export from League of Comic Geeks ‚Üí Bulk Import/Export</p>
                  </div>

                  {importPreview.length > 0 && (
                    <div>
                      <div className="flex gap-4 mb-3">
                        <div className="bg-blue-50 px-3 py-1 rounded"><span className="font-bold text-blue-700">{importStats.new}</span> new</div>
                        <div className="bg-gray-50 px-3 py-1 rounded"><span className="font-bold text-gray-600">{importStats.existing}</span> existing</div>
                        <div className="bg-red-50 px-3 py-1 rounded"><span className="font-bold text-red-700">{importStats.unmatched}</span> unmatched</div>
                      </div>
                      
                      <div className="max-h-64 overflow-y-auto border rounded">
                        <table className="w-full text-sm">
                          <thead className="bg-gray-100 sticky top-0">
                            <tr>
                              <th className="text-left p-2">Import</th>
                              <th className="text-left p-2">Title</th>
                              <th className="text-left p-2">Matched To</th>
                              <th className="text-left p-2">Status</th>
                            </tr>
                          </thead>
                          <tbody>
                            {importPreview.slice(0, 100).map((item, i) => (
                              <tr key={i} className="border-t">
                                <td className="p-2">
                                  <input 
                                    type="checkbox" 
                                    checked={item.import} 
                                    onChange={() => {
                                      const updated = [...importPreview];
                                      updated[i].import = !updated[i].import;
                                      setImportPreview(updated);
                                    }}
                                    disabled={item.status === 'existing' || item.status === 'unmatched'}
                                  />
                                </td>
                                <td className="p-2 truncate max-w-xs" title={item.fullTitle}>{item.fullTitle}</td>
                                <td className="p-2">{item.matchedSeries?.name || '‚Äî'}</td>
                                <td className="p-2"><StatusBadge status={item.status} /></td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                      
                      <div className="mt-3 flex gap-2">
                        <button onClick={executeImport} disabled={saving || importStats.new === 0} className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                          {saving ? 'Importing...' : `Import ${importPreview.filter(p => p.import).length} Issues`}
                        </button>
                        <button onClick={() => { setImportData(null); setImportPreview([]); }} className="px-4 py-2 bg-gray-200 rounded">Cancel</button>
                      </div>
                    </div>
                  )}
                </div>
              )}

              {adminMode === 'export' && (
                <div className="text-center py-6">
                  <p className="text-gray-600 mb-4">Export your collection in League of Comic Geeks format</p>
                  <button onClick={exportForLOCG} className="px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 text-lg">
                    üì§ Export for LOCG
                  </button>
                  <p className="text-sm text-gray-500 mt-3">Then import the file at LOCG ‚Üí Bulk Import/Export</p>
                </div>
              )}
            </div>
          )}

          {/* Stats */}
          <div className="grid grid-cols-5 gap-3 mb-4">
            <div className="bg-white p-3 rounded shadow text-center">
              <div className="text-2xl font-bold text-green-600">${totalSpent.toLocaleString()}</div>
              <div className="text-xs text-gray-500">Invested</div>
            </div>
            <div className="bg-white p-3 rounded shadow text-center">
              <div className="text-2xl font-bold text-blue-600">{ownedBooks}</div>
              <div className="text-xs text-gray-500">Owned</div>
            </div>
            <div className="bg-white p-3 rounded shadow text-center">
              <div className="text-2xl font-bold text-yellow-600">{pendingBooks}</div>
              <div className="text-xs text-gray-500">Pending</div>
            </div>
            <div className="bg-white p-3 rounded shadow text-center">
              <div className="text-2xl font-bold text-purple-600">{completeRuns}</div>
              <div className="text-xs text-gray-500">Complete</div>
            </div>
            <div className="bg-white p-3 rounded shadow text-center">
              <div className="text-2xl font-bold text-red-600">{gaps.length}</div>
              <div className="text-xs text-gray-500">Gaps</div>
            </div>
          </div>

          {/* Tabs */}
          <div className="flex gap-2 mb-4 border-b">
            {['overview', 'pending', 'gaps', 'gifts'].map(tab => (
              <button key={tab} onClick={() => setActiveTab(tab)}
                className={`px-4 py-2 font-medium ${activeTab === tab ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-500'}`}>
                {tab.charAt(0).toUpperCase() + tab.slice(1)}
              </button>
            ))}
          </div>

          {/* Overview Tab */}
          {activeTab === 'overview' && (
            <div>
              <div className="flex gap-2 mb-4">
                {['all', 'complete', 'in-progress', 'dc', 'marvel'].map(f => (
                  <button key={f} onClick={() => setFilter(f)}
                    className={`px-3 py-1 rounded text-sm ${filter === f ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
                    {f.charAt(0).toUpperCase() + f.slice(1)}
                  </button>
                ))}
              </div>
              <div className="space-y-2">
                {filteredSeries.map(s => {
                  const seriesIssues = getSeriesIssues(s.id);
                  const owned = seriesIssues.filter(i => i.status === 'owned').length;
                  const pending = seriesIssues.filter(i => i.status === 'pending').length;
                  return (
                    <div key={s.id} className="bg-white rounded shadow">
                      <div className="p-3 flex justify-between items-center cursor-pointer hover:bg-gray-50" onClick={() => toggleExpand(s.id)}>
                        <div className="flex items-center gap-3">
                          <span className="font-medium">{s.name}</span>
                          <StatusBadge status={s.status} />
                          <span className="text-xs text-gray-400">{s.publisher}</span>
                        </div>
                        <div className="flex items-center gap-4 text-sm">
                          <span className="text-green-600">{owned} owned</span>
                          {pending > 0 && <span className="text-yellow-600">{pending} pending</span>}
                          <span className="text-gray-500">${s.total_spent}</span>
                          <span className="text-gray-400">{expanded[s.id] ? '‚ñº' : '‚ñ∂'}</span>
                        </div>
                      </div>
                      {expanded[s.id] && (
                        <div className="px-3 pb-3 border-t">
                          {s.notes && <p className="text-sm text-gray-500 mt-2">{s.notes}</p>}
                          <div className="grid grid-cols-4 gap-2 mt-2">
                            {seriesIssues.map(issue => (
                              <div key={issue.id} className={`p-2 rounded text-xs ${issue.status === 'owned' ? 'bg-green-50' : 'bg-yellow-50'}`}>
                                <div className="font-medium flex justify-between">
                                  <span>{issue.issue_number}</span>
                                  {issue.is_key_issue && <span className="text-orange-500">‚òÖ</span>}
                                </div>
                                <div className="text-gray-500 truncate">{issue.covers?.join(', ')}</div>
                                {issue.notes && <div className="text-orange-600 mt-1">{issue.notes}</div>}
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Pending Tab */}
          {activeTab === 'pending' && (
            <div className="bg-white rounded shadow p-4">
              <h2 className="font-bold text-lg mb-3">Pending Items ({pendingBooks})</h2>
              <div className="space-y-2">
                {issues.filter(i => i.status === 'pending').map(issue => {
                  const issueSeries = series.find(s => s.id === issue.series_id);
                  return (
                    <div key={issue.id} className="p-2 border rounded flex justify-between items-center">
                      <div>
                        <span className="font-medium">{issueSeries?.name}</span>
                        <span className="text-gray-500 ml-2">{issue.issue_number}</span>
                      </div>
                      <div className="text-sm text-gray-500">{issue.covers?.join(', ')}</div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Gaps Tab */}
          {activeTab === 'gaps' && (
            <div className="bg-white rounded shadow p-4">
              <h2 className="font-bold text-lg mb-3">Collection Gaps ({gaps.length})</h2>
              <div className="space-y-2">
                {gaps.map(gap => {
                  const gapSeries = series.find(s => s.id === gap.series_id);
                  const pc = { high: 'border-l-red-500', medium: 'border-l-yellow-500', low: 'border-l-gray-300' };
                  return (
                    <div key={gap.id} className={`p-3 border-l-4 ${pc[gap.priority]} bg-gray-50 rounded`}>
                      <div className="flex justify-between">
                        <div>
                          <span className="font-medium">{gapSeries?.name}</span>
                          <span className="text-gray-500 ml-2">{gap.issue_number}</span>
                          <span className="text-gray-400 ml-2">({gap.cover_needed})</span>
                        </div>
                        <div className="text-green-600 font-medium">${gap.estimated_cost}</div>
                      </div>
                      {gap.notes && <p className="text-sm text-gray-500 mt-1">{gap.notes}</p>}
                    </div>
                  );
                })}
                <div className="mt-4 p-3 bg-blue-50 rounded">
                  <strong>Total to fill gaps:</strong> ${gaps.reduce((sum, g) => sum + (parseFloat(g.estimated_cost) || 0), 0)}
                </div>
              </div>
            </div>
          )}

          {/* Gifts Tab */}
          {activeTab === 'gifts' && (
            <div className="bg-white rounded shadow p-4">
              <h2 className="font-bold text-lg mb-3">Gift List</h2>
              {gifts.map(gift => (
                <div key={gift.id} className="p-3 border rounded flex justify-between items-center mb-2">
                  <div>
                    <div className="font-medium">{gift.item_description}</div>
                    <div className="text-sm text-gray-500">For: {gift.recipient}</div>
                  </div>
                  <StatusBadge status={gift.status} />
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
